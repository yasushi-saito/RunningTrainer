package com.ysaito.runningtrainer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.regex.Pattern;

import android.content.Context;
import android.util.Log;
import android.widget.Toast;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class RecordManager {
	private final static String TAG = "Util";
	
	// The SDCARD directory in which records are stored
	private final File mRootDir;
	private final Context mContext;
	
	public RecordManager(Context context) {
		// File externalDir = context.getExternalFilesDir(null);
		File externalDir = new File("/sdcard/com.ysaito.runningtrainer");
		mContext = context;
		if (externalDir == null) {
        	Toast.makeText(context, "SD card is not found on this device. No record will be kept", Toast.LENGTH_LONG).show();
        	mRootDir = null;
		} else {
			mRootDir = new File(externalDir, "com.ysaito.RunningTrainer");
			if (!mRootDir.exists()) {
				if (!mRootDir.mkdirs()) {
					Toast.makeText(context, mRootDir.getPath() + ": failed to create directory", Toast.LENGTH_LONG).show();
				}
			}
		}
	}

	/**
	 * Given an activity record, generate the summary object that includes that the filename (basename) that will store the record. 
	 * This function is public only for testing.
	 * 
	 * @param startTime The time the activity. Milliseconds since 1970/1/1. 
	 * @param record The record itself. This method does not modify the record
	 * 
	 * @return File, in the form "log:<params>.json" 
	 */
	static public String generateBasename(long startTime, HealthGraphClient.JsonActivity record) {
		StringBuilder b = new StringBuilder("log:s=");
		b.append(startTime);
		b.append(":d=");
		b.append(record.total_distance);
		b.append(":e=");
		b.append(record.duration);
		b.append(":.json");
		return b.toString();
	}
	
	/**
	 * Parse the basename generated by generateBasename.
	 * This method is public only for testing.
	 * 
	 *  @return The struct containing the parsed result, or null if the basename is malformed. 
	 */
	static final Pattern P0 = Pattern.compile("log");
	static final Pattern P1 = Pattern.compile("([a-zA-Z+])=([0-9.]+)");
	
	static public RecordSummary parseBasename(String basename) {
		try {
			RecordSummary r = new RecordSummary();
			Scanner scanner = new Scanner(basename).useDelimiter(":");
			scanner.skip(P0);  // will raise exception on mismatch
			r.basename = basename; 
			while (scanner.hasNext(P1)) {
				final String type = scanner.match().group(1);
				final String value = scanner.match().group(2);
				scanner.next(P1);
				if (type.equals("s")) {
					r.startTime = Long.parseLong(value);
				} else if (type.equals("d")) {
					r.totalDistance = Double.parseDouble(value);
				} else if (type.equals("e")) {
					r.duration = Double.parseDouble(value);
				}
			}
			String s = scanner.next();
			if (!s.equals(".json")) {
				return null;
			}
			return r;
		} catch (Exception e) {
			Log.e(TAG, basename + ": Failed to parse the basenam");
			return null;
		}
	}
	
	public void addRecord(long startTime, HealthGraphClient.JsonActivity record) {
		if (mRootDir == null) return;
		Gson gson = new GsonBuilder().create();
		try {
			File destFile = new File(mRootDir, generateBasename(startTime, record));
			FileWriter out = new FileWriter(destFile);
			gson.toJson(record, out);
			out.close();
			Toast.makeText(mContext, "Wrote record to " + destFile.getPath(), Toast.LENGTH_LONG).show();
		} catch (IOException e) {
			Toast.makeText(mContext, mRootDir.getPath() + ": failed to save log: " + e.toString(), Toast.LENGTH_LONG).show();
		}
	}
	
	public HealthGraphClient.JsonActivity readRecord(String basename) {
		File sourceFile = new File(mRootDir, basename);
		try {
			Gson gson = new GsonBuilder().create();
			return gson.fromJson(new BufferedReader(new FileReader(sourceFile)), HealthGraphClient.JsonActivity.class);
		} catch (IOException e) {
			Toast.makeText(mContext, sourceFile.getPath() + ": " + e.toString(), Toast.LENGTH_LONG).show();
		}
		return null;
	}
	
	public void deleteRecord(RecordSummary summary) {
		// TODO: implement
	}
	
	public ArrayList<RecordSummary> listRecords() {
		ArrayList<RecordSummary> list = new ArrayList<RecordSummary>();
		if (mRootDir != null) {
			for (String basename : mRootDir.list()) {
				Log.d(TAG, "File: " + basename);
				if (basename.startsWith("log:")) {
					RecordSummary summary = parseBasename(basename);
					if (summary != null) list.add(summary);
				}
			}
		}
	    return list;
	}
}
